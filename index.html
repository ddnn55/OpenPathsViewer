<!DOCTYPE html>
<meta charset="utf-8">
<title>Reprojected Raster Tiles</title>
<style>
@import url(../maps.css);

#map {
  position: relative;
  margin: 0 auto;
  overflow: hidden;
}

#map svg {
  position: absolute;
  left: 0px;
  top: 0px;
}

.tile {
  position: absolute;
}

.points {
  fill: crimson;
}






svg.brush {
  font: 10px sans-serif;
}

.brush path {
  fill: steelblue;
}

.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.brush .extent {
  stroke: #fff;
  fill-opacity: .125;
  shape-rendering: crispEdges;
}





</style>

<div id="map"></div>

<script src="stats.js"></script>

<script src="d3.v3.min.js"></script>
<script src="d3.geo.projection.min.js"></script>
<script src="topojson.min.js"></script>
<script src="d3.quadtiles.js"></script>
<script src="d3.geo.raster.js"></script>
<script>

var stats = new Stats();
stats.setMode(1); // 0: fps, 1: ms

// Align top-left
stats.domElement.style.position = 'absolute';
stats.domElement.style.left = '0px';
stats.domElement.style.top = '0px';

document.body.appendChild( stats.domElement );


var ratio = 1,
    width = 960 * ratio,
    height = 500 * ratio,
    p = .5;

var projection = d3.geo.albers()
    .rotate([0, 0])
    .center([0, 52])
    .scale(150 * ratio)
    .translate([width / 2, height / 2])
    .clipExtent([[p, p], [width - p, height - p]]);

var raster = d3.geo.raster(projection)
    .url("http://api.tiles.mapbox.com/v3/examples.map-zr0njcqy/{z}/{x}/{y}.png32");

var openPaths2GeoJson = function(op) {

  var lines = op.slice(1).map(function(d, i) {
    
    var p1 = op[i],  // from
        p2 = op[i+1] // to

    return {
      "type": "LineString",
      "coordinates": [
        [+p1.lon, +p1.lat],
        [+p2.lon, +p2.lat]
      ]
    }

  });

  return op.map(function(d, i) {
    return {
      "type": "Feature",
      "geometry": {"type": "Point", "coordinates": [+d.lon, +d.lat]}
    }
  });

}

var path = d3.geo.path().projection(projection);

var pointsG;


d3.csv("openpaths_davidstolarsky.csv", function(err, data) {
  
  //data = data.filter(function(d, i) { return i % 1500 == 0 })
  features = openPaths2GeoJson(data);

  var layer = d3.select("#map")
      .style("width", width / ratio + "px")
      .style("height", height / ratio + "px")
      .call(d3.behavior.zoom()
        .translate([.5 * width / ratio, .5 * height / ratio])
        .scale(projection.scale() / ratio)
        .scaleExtent([1e2, 1e8])
        .on("zoom", function() {
          
          stats.end();
  
          var t = d3.event.translate,
              s = d3.event.scale;
  
 
          projection.translate([t[0] * ratio, t[1] * ratio]).scale(s * ratio);
          layer.call(raster);

          // magic numbers :( instead should detect/target frame rate if possible?
          var percentPointsVisible = 0.1 + 0.9 * s / 600000;
          var countPointsVisible = percentPointsVisible * features.length;
          var visiblePointPeriod = Math.ceil(features.length / countPointsVisible);

          var sampledFeatures = features.filter(function(d, i) {
            return i % visiblePointPeriod == 0;
          })

          console.log(visiblePointPeriod, sampledFeatures.length);

          pointsG.select("path")
            .datum({
              "type": "FeatureCollection",
              "features": sampledFeatures
            })
              .attr("d", path);
  
          stats.begin();
  
        }))
    .append("div")
      .attr("class", "layer-outer-container")
      .style(prefix + "transform-origin", "0 0 0")
    .append("div")
      .attr("class", "layer-inner-container")
      .style(prefix + "transform-origin", "0 0 0")
      .call(raster);


  pointsG = d3.select("#map").append("svg").append("g")
      .attr("class", "points");

  pointsG.append("path")
    .datum({
              "type": "FeatureCollection",
              "features": features
            })
    .attr("d", path);

});









(function() {

  var margin = {top: 0, right: 0, bottom: 0, left: 0},
      margin2 = {top: 0, right: 0, bottom: 20, left: 0},
      width = 960 - margin.left - margin.right,
      height = 100 - margin.top - margin.bottom,
      height2 = 100 - margin2.top - margin2.bottom;
  
  var parseDate = d3.time.format("%b %Y").parse;
  
  var x = d3.time.scale().range([0, width]),
      x2 = d3.time.scale().range([0, width]),
      y = d3.scale.linear().range([height, 0]),
      y2 = d3.scale.linear().range([height2, 0]);
  
  var xAxis2 = d3.svg.axis().scale(x2).orient("bottom");
  
  var brush = d3.svg.brush()
      .x(x2)
      .on("brush", brushed);
  
  var area = d3.svg.area()
      .interpolate("monotone")
      .x(function(d) { return x(d.date); })
      .y0(height)
      .y1(function(d) { return y(d.price); });
  
  var area2 = d3.svg.area()
      .interpolate("monotone")
      .x(function(d) { return x2(d.date); })
      .y0(height2)
      .y1(function(d) { return y2(d.price); });
  
  var svg = d3.select("body").append("svg")
      .attr("class", "brush")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom);
  
  svg.append("defs").append("clipPath")
      .attr("id", "clip")
    .append("rect")
      .attr("width", width)
      .attr("height", height);
  
  var context = svg.append("g")
      .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");
  
  d3.csv("sp500.csv", function(error, data) {
  
    data.forEach(function(d) {
      d.date = parseDate(d.date);
      d.price = +d.price;
    });
  
    x.domain(d3.extent(data.map(function(d) { return d.date; })));
    y.domain([0, d3.max(data.map(function(d) { return d.price; }))]);
    x2.domain(x.domain());
    y2.domain(y.domain());

  
    context.append("path")
        .datum(data)
        .attr("d", area2);
  
    context.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height2 + ")")
        .call(xAxis2);
  
    context.append("g")
        .attr("class", "x brush")
        .call(brush)
      .selectAll("rect")
        .attr("y", -6)
        .attr("height", height2 + 7);
  });
  
  function brushed() {
    //x.domain(brush.empty() ? x2.domain() : brush.extent());
    //focus.select("path").attr("d", area);
    //focus.select(".x.axis").call(xAxis);
  }

})();









</script>
